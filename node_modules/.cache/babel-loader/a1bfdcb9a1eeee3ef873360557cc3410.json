{"ast":null,"code":"export default function (topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1; // Stitch empty arcs first, since they may be subsumed by other arcs.\n\n  arcs.forEach(function (i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i],\n        t;\n\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n  arcs.forEach(function (i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f,\n        g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i],\n        p0 = arc[0],\n        p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {\n      p1[0] += dp[0], p1[1] += dp[1];\n    });else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function (i) {\n        stitchedArcs[i < 0 ? ~i : i] = 1;\n      });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function (i) {\n    if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);\n  });\n  return fragments;\n}","map":{"version":3,"sources":["D:/eclipse/work3/starlink/node_modules/topojson-client/src/stitch.js"],"names":["topology","arcs","stitchedArcs","fragmentByStart","fragmentByEnd","fragments","emptyIndex","forEach","i","j","arc","t","length","e","ends","start","end","f","g","push","fg","concat","unshift","gf","p0","p1","transform","dp","flush","k"],"mappings":"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","sourcesContent":["export default function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n"]},"metadata":{},"sourceType":"module"}