{"ast":null,"code":"import bbox from \"./bbox.js\";\nimport untransform from \"./untransform.js\";\nexport default function (topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0],\n        y0 = box[1],\n        x1 = box[2],\n        y1 = box[3],\n        n;\n    transform = {\n      scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1],\n      translate: [x0, y0]\n    };\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform),\n      box,\n      key,\n      inputs = topology.objects,\n      outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n\n    switch (input.type) {\n      case \"GeometryCollection\":\n        output = {\n          type: \"GeometryCollection\",\n          geometries: input.geometries.map(quantizeGeometry)\n        };\n        break;\n\n      case \"Point\":\n        output = {\n          type: \"Point\",\n          coordinates: quantizePoint(input.coordinates)\n        };\n        break;\n\n      case \"MultiPoint\":\n        output = {\n          type: \"MultiPoint\",\n          coordinates: input.coordinates.map(quantizePoint)\n        };\n        break;\n\n      default:\n        return input;\n    }\n\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0,\n        j = 1,\n        n = input.length,\n        p,\n        output = new Array(n); // pessimistic\n\n    output[0] = t(input[0], 0);\n\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n\n\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}","map":{"version":3,"sources":["D:/eclipse/work3/starlink/node_modules/topojson-client/src/quantize.js"],"names":["bbox","untransform","topology","transform","Error","scale","n","Math","floor","box","x0","y0","x1","y1","translate","t","key","inputs","objects","outputs","quantizePoint","point","quantizeGeometry","input","output","type","geometries","map","coordinates","id","properties","quantizeArc","i","j","length","p","Array","arcs"],"mappings":"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","sourcesContent":["import bbox from \"./bbox.js\";\nimport untransform from \"./untransform.js\";\n\nexport default function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n"]},"metadata":{},"sourceType":"module"}