{"ast":null,"code":"import { object } from \"./feature.js\";\nimport stitch from \"./stitch.js\";\n\nfunction planarRingArea(ring) {\n  var i = -1,\n      n = ring.length,\n      a,\n      b = ring[n - 1],\n      area = 0;\n\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n\n  return Math.abs(area); // Note: doubled area!\n}\n\nexport default function (topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\nexport function mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\":\n        o.geometries.forEach(geometry);\n        break;\n\n      case \"Polygon\":\n        extract(o.arcs);\n        break;\n\n      case \"MultiPolygon\":\n        o.arcs.forEach(extract);\n        break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function (ring) {\n      ring.forEach(function (arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {\n      type: \"Polygon\",\n      arcs: [ring]\n    }).coordinates[0]);\n  }\n\n  polygons.forEach(function (polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function (ring) {\n          ring.forEach(function (arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n  polygons.forEach(function (polygon) {\n    delete polygon._;\n  });\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function (polygons) {\n      var arcs = [],\n          n; // Extract the exterior (unique) arcs.\n\n      polygons.forEach(function (polygon) {\n        polygon.forEach(function (ring) {\n          ring.forEach(function (arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      }); // Stitch the arcs into one or more rings.\n\n      arcs = stitch(topology, arcs); // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    }).filter(function (arcs) {\n      return arcs.length > 0;\n    })\n  };\n}","map":{"version":3,"sources":["D:/eclipse/work3/starlink/node_modules/topojson-client/src/merge.js"],"names":["object","stitch","planarRingArea","ring","i","n","length","a","b","area","Math","abs","topology","mergeArcs","apply","arguments","objects","polygonsByArc","polygons","groups","forEach","geometry","o","type","geometries","extract","arcs","polygon","arc","push","coordinates","_","group","neighbors","pop","map","k","ki","t","filter"],"mappings":"AAAA,SAAQA,MAAR,QAAqB,cAArB;AACA,OAAOC,MAAP,MAAmB,aAAnB;;AAEA,SAASC,cAAT,CAAwBC,IAAxB,EAA8B;AAC5B,MAAIC,CAAC,GAAG,CAAC,CAAT;AAAA,MAAYC,CAAC,GAAGF,IAAI,CAACG,MAArB;AAAA,MAA6BC,CAA7B;AAAA,MAAgCC,CAAC,GAAGL,IAAI,CAACE,CAAC,GAAG,CAAL,CAAxC;AAAA,MAAiDI,IAAI,GAAG,CAAxD;;AACA,SAAO,EAAEL,CAAF,GAAMC,CAAb,EAAgBE,CAAC,GAAGC,CAAJ,EAAOA,CAAC,GAAGL,IAAI,CAACC,CAAD,CAAf,EAAoBK,IAAI,IAAIF,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAR,GAAcD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAlD;;AAChB,SAAOE,IAAI,CAACC,GAAL,CAASF,IAAT,CAAP,CAH4B,CAGL;AACxB;;AAED,eAAe,UAASG,QAAT,EAAmB;AAChC,SAAOZ,MAAM,CAACY,QAAD,EAAWC,SAAS,CAACC,KAAV,CAAgB,IAAhB,EAAsBC,SAAtB,CAAX,CAAb;AACD;AAED,OAAO,SAASF,SAAT,CAAmBD,QAAnB,EAA6BI,OAA7B,EAAsC;AAC3C,MAAIC,aAAa,GAAG,EAApB;AAAA,MACIC,QAAQ,GAAG,EADf;AAAA,MAEIC,MAAM,GAAG,EAFb;AAIAH,EAAAA,OAAO,CAACI,OAAR,CAAgBC,QAAhB;;AAEA,WAASA,QAAT,CAAkBC,CAAlB,EAAqB;AACnB,YAAQA,CAAC,CAACC,IAAV;AACE,WAAK,oBAAL;AAA2BD,QAAAA,CAAC,CAACE,UAAF,CAAaJ,OAAb,CAAqBC,QAArB;AAAgC;;AAC3D,WAAK,SAAL;AAAgBI,QAAAA,OAAO,CAACH,CAAC,CAACI,IAAH,CAAP;AAAiB;;AACjC,WAAK,cAAL;AAAqBJ,QAAAA,CAAC,CAACI,IAAF,CAAON,OAAP,CAAeK,OAAf;AAAyB;AAHhD;AAKD;;AAED,WAASA,OAAT,CAAiBE,OAAjB,EAA0B;AACxBA,IAAAA,OAAO,CAACP,OAAR,CAAgB,UAASjB,IAAT,EAAe;AAC7BA,MAAAA,IAAI,CAACiB,OAAL,CAAa,UAASQ,GAAT,EAAc;AACzB,SAACX,aAAa,CAACW,GAAG,GAAGA,GAAG,GAAG,CAAN,GAAU,CAACA,GAAX,GAAiBA,GAAxB,CAAb,KAA8CX,aAAa,CAACW,GAAD,CAAb,GAAqB,EAAnE,CAAD,EAAyEC,IAAzE,CAA8EF,OAA9E;AACD,OAFD;AAGD,KAJD;AAKAT,IAAAA,QAAQ,CAACW,IAAT,CAAcF,OAAd;AACD;;AAED,WAASlB,IAAT,CAAcN,IAAd,EAAoB;AAClB,WAAOD,cAAc,CAACF,MAAM,CAACY,QAAD,EAAW;AAACW,MAAAA,IAAI,EAAE,SAAP;AAAkBG,MAAAA,IAAI,EAAE,CAACvB,IAAD;AAAxB,KAAX,CAAN,CAAkD2B,WAAlD,CAA8D,CAA9D,CAAD,CAArB;AACD;;AAEDZ,EAAAA,QAAQ,CAACE,OAAT,CAAiB,UAASO,OAAT,EAAkB;AACjC,QAAI,CAACA,OAAO,CAACI,CAAb,EAAgB;AACd,UAAIC,KAAK,GAAG,EAAZ;AAAA,UACIC,SAAS,GAAG,CAACN,OAAD,CADhB;AAEAA,MAAAA,OAAO,CAACI,CAAR,GAAY,CAAZ;AACAZ,MAAAA,MAAM,CAACU,IAAP,CAAYG,KAAZ;;AACA,aAAOL,OAAO,GAAGM,SAAS,CAACC,GAAV,EAAjB,EAAkC;AAChCF,QAAAA,KAAK,CAACH,IAAN,CAAWF,OAAX;AACAA,QAAAA,OAAO,CAACP,OAAR,CAAgB,UAASjB,IAAT,EAAe;AAC7BA,UAAAA,IAAI,CAACiB,OAAL,CAAa,UAASQ,GAAT,EAAc;AACzBX,YAAAA,aAAa,CAACW,GAAG,GAAG,CAAN,GAAU,CAACA,GAAX,GAAiBA,GAAlB,CAAb,CAAoCR,OAApC,CAA4C,UAASO,OAAT,EAAkB;AAC5D,kBAAI,CAACA,OAAO,CAACI,CAAb,EAAgB;AACdJ,gBAAAA,OAAO,CAACI,CAAR,GAAY,CAAZ;AACAE,gBAAAA,SAAS,CAACJ,IAAV,CAAeF,OAAf;AACD;AACF,aALD;AAMD,WAPD;AAQD,SATD;AAUD;AACF;AACF,GApBD;AAsBAT,EAAAA,QAAQ,CAACE,OAAT,CAAiB,UAASO,OAAT,EAAkB;AACjC,WAAOA,OAAO,CAACI,CAAf;AACD,GAFD;AAIA,SAAO;AACLR,IAAAA,IAAI,EAAE,cADD;AAELG,IAAAA,IAAI,EAAEP,MAAM,CAACgB,GAAP,CAAW,UAASjB,QAAT,EAAmB;AAClC,UAAIQ,IAAI,GAAG,EAAX;AAAA,UAAerB,CAAf,CADkC,CAGlC;;AACAa,MAAAA,QAAQ,CAACE,OAAT,CAAiB,UAASO,OAAT,EAAkB;AACjCA,QAAAA,OAAO,CAACP,OAAR,CAAgB,UAASjB,IAAT,EAAe;AAC7BA,UAAAA,IAAI,CAACiB,OAAL,CAAa,UAASQ,GAAT,EAAc;AACzB,gBAAIX,aAAa,CAACW,GAAG,GAAG,CAAN,GAAU,CAACA,GAAX,GAAiBA,GAAlB,CAAb,CAAoCtB,MAApC,GAA6C,CAAjD,EAAoD;AAClDoB,cAAAA,IAAI,CAACG,IAAL,CAAUD,GAAV;AACD;AACF,WAJD;AAKD,SAND;AAOD,OARD,EAJkC,CAclC;;AACAF,MAAAA,IAAI,GAAGzB,MAAM,CAACW,QAAD,EAAWc,IAAX,CAAb,CAfkC,CAiBlC;AACA;AACA;;AACA,UAAI,CAACrB,CAAC,GAAGqB,IAAI,CAACpB,MAAV,IAAoB,CAAxB,EAA2B;AACzB,aAAK,IAAIF,CAAC,GAAG,CAAR,EAAWgC,CAAC,GAAG3B,IAAI,CAACiB,IAAI,CAAC,CAAD,CAAL,CAAnB,EAA8BW,EAA9B,EAAkCC,CAAvC,EAA0ClC,CAAC,GAAGC,CAA9C,EAAiD,EAAED,CAAnD,EAAsD;AACpD,cAAI,CAACiC,EAAE,GAAG5B,IAAI,CAACiB,IAAI,CAACtB,CAAD,CAAL,CAAV,IAAuBgC,CAA3B,EAA8B;AAC5BE,YAAAA,CAAC,GAAGZ,IAAI,CAAC,CAAD,CAAR,EAAaA,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAACtB,CAAD,CAA3B,EAAgCsB,IAAI,CAACtB,CAAD,CAAJ,GAAUkC,CAA1C,EAA6CF,CAAC,GAAGC,EAAjD;AACD;AACF;AACF;;AAED,aAAOX,IAAP;AACD,KA7BK,EA6BHa,MA7BG,CA6BI,UAASb,IAAT,EAAe;AACvB,aAAOA,IAAI,CAACpB,MAAL,GAAc,CAArB;AACD,KA/BK;AAFD,GAAP;AAmCD","sourcesContent":["import {object} from \"./feature.js\";\nimport stitch from \"./stitch.js\";\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nexport default function(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nexport function mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    }).filter(function(arcs) {\n      return arcs.length > 0;\n    })\n  };\n}\n"]},"metadata":{},"sourceType":"module"}